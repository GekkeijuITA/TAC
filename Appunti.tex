\documentclass[12pt, a4paper]{report}
\usepackage[utf8]{inputenc}
\usepackage{titlesec}
\titleformat{\chapter}[display]
    {\normalfont\huge\bfseries}
    {} 
    {0pt}
    {\Huge Capitolo~\thechapter: }

\titlespacing*{\chapter}{0pt}{50pt}{40pt}

\input{variables.tex}
\input{titlePage.tex}

\preamble
\begin{document}
    \customTitlePage{Teoria degli Automi e Calcolabilità}{Lorenzo Vaccarecci}{Anno Accademico 2024/2025}{Università degli Studi di Genova}
    \newpage
    \tableofcontents
    \chapter{Preliminari}
        \section{Alfabeti, stringhe, linguaggi}
            \begin{definitionbox}{Alfabeto}{}
                Insieme finito \textbf{non vuoto} di oggetti detti \textit{simboli}.
            \end{definitionbox}
            \begin{definitionbox}{Stringa}{}
                Una stringa $u$ su un alfabeto $\Sigma$ è una funzione totale da $[1,n]$ in $\Sigma$, per qualche $n\in\mathbb{N}$. 
                $n$ si dice \textit{lunghezza} di $u$ e si indica con $|u|$. 
            \end{definitionbox}
            \begin{itemize}
                \item $[1,n]\rightarrow$ sono le posizioni dei simboli all'interno della stringa 
                \item Per \textbf{funzione totale} intendiamo che per ogni posizione nell'intervallo $[1,n]$ deve avere un simbolo corrispondente 
            \end{itemize}
            Da ora in poi: 
            \begin{itemize}
                \item $\sigma\rightarrow$ simboli generici 
                \item $u,v,w\rightarrow$ stringhe generiche 
                \item $\bigwedge\text{ o }\varepsilon\rightarrow$ stringa vuota con lunghezza zero ($\left|\bigwedge\right|=0$ o $\left|\varepsilon\right|=0$) 
            \end{itemize}
            \begin{definitionbox}{Linguaggio $L$}{}
                E' un insieme di stringhe su $\Sigma$, ossia un sottoinsieme di $\Sigma^*$ \textbf{infinito e numerabile}. 
            \end{definitionbox}
            \begin{itemize}
                \item \textbf{Infinito}: contiene un numero illimitato di elementi 
                \item \textbf{Numerabile}: esiste una funzione iniettiva da $\Sigma^*$ all'insieme dei numeri naturali $\mathbb{N}$ 
            \end{itemize}
            L'insieme $\emptyset$ è un linguaggio che non contiene alcun elemento (neanche la stringa vuota). 
            L'insieme $\{\varepsilon\}$ è composto solo da una stringa di lunghezza 0. 
            \textit{Esempio:}
            \begin{itemize}
                \item $\Sigma=\{a,b\}$ 
                \item $L=\Sigma^*=\{\varepsilon, a, b, aa, ab, ba, bb, aaa, aab, \ldots\}$ 
            \end{itemize}
            \textbf{Un linguaggio può non contenere $\varepsilon$}. 
            \begin{definitionbox}{Operazioni su stringhe (concatenazione)}{}
                Se $u$ e $v$ sono stringhe di lunghezza $n$ ed $m$ rispettivamente, allora $u\cdot v$ è la stringa di lunghezza $n+m$, definita da 
                \begin{equation*}
                    (u\cdot v)(k)=\begin{cases}
                        u(k) & \text{se } 1\leq k\leq n\\
                        v(k-n) & \text{se } n<k\leq n+m 
                    \end{cases}
                \end{equation*}
                Questa operazione è \underline{associativa}. 
            \end{definitionbox}
            \begin{definitionbox}{Operazioni su linguaggi (concatenazione)}{}
                Se $L$ e $L'$ sono linguaggi, $L\cdot L'=\{u\cdot v\mid u\in L, v\in L'\}$. 
                Se si esegue: 
                \begin{equation*}
                    \begin{split}
                        &L\cdot \{\varepsilon\}=L \qquad L\cdot \emptyset = \emptyset \\
                        &L^0=\left\{\varepsilon\right\} \qquad L^{n+1}=L\cdot L^n \qquad \text{con } n\geq 0 
                    \end{split}
                \end{equation*}
                \begin{itemize}
                    \item \textbf{Chiusura di Kleene $L^*$}: $L^*=\cup_{n\geq 0}L^{n}\rightarrow$ collezione di tutte le sequenze possibili di elementi di $L$, inclusa la stringa vuota ($L^0$). 
                    \textit{Esempio:}
                    \begin{itemize}
                        \item $\Sigma=\{a,b\}$ 
                        \item $L=\{a\}$ 
                        \item $L^*=\{\varepsilon, a, aa, aaa, \ldots, a^n\}$ 
                    \end{itemize}
                    \item \textbf{Chiusura positiva $L^+$}: $L^+=\cup_{n>0}L^n\rightarrow$ differisce da $L^*$ solo per l'esclusione della stringa vuota, a meno che $L$ stesso contenga $\varepsilon$. 
                    \textit{Esempio:}
                    \begin{itemize}
                        \item $L^+=\{a, aa, aaa, \ldots, a^n\}$ 
                    \end{itemize}
                \end{itemize}
                Questa operazione è \underline{associativa}.
            \end{definitionbox}
    \chapter{Automi a stati finiti}
        \section{Linguaggi regolari}
            \subsection{Automi a stati finiti}
                \begin{definitionbox}{Automa a stato finito deterministico (DFA)}{}
                    E' una quintupla $\mathcal{M}=\langle Q,\Sigma, \delta, q_0, F\rangle$ dove:
                    \begin{itemize}
                        \item $Q$ è un insieme finito di stati
                        \item $\Sigma$ è un alfabeto di input
                        \item $\delta:Q\times\Sigma\rightarrow Q$ è una funzione totale detta \textbf{funzione di transizione} ovvero stabilisce come l'automa si muove da uno stato all'altro in base al simbolo che legge dall'input
                        \item $q_0\in Q$ è lo stato iniziale
                        \item $F\subseteq Q$ è l'insieme degli stati finali
                    \end{itemize}
                \end{definitionbox}
                La definizione del sistema di transizione associato a un DFA $\mathcal{M}$ è:
                \begin{itemize}
                    \item \textbf{Configurazioni}: sono rappresentate da una coppia $\langle q,u \rangle$: \begin{itemize}
                        \item $q\in Q$ è lo stato corrente in cui si trova l'automa
                        \item $u\in\Sigma^*$ è la parte della stringa di input che deve ancora essere letta
                    \end{itemize}
                    \item \textbf{Relazione di Riduzione (o Transizione)}: la relazione di riduzione, indicata con $\to$, definisce come l'automa si muove da una configurazione all'altra: \begin{equation*}
                        \langle q,\sigma u\rangle\to\langle q',u\rangle \text{ se } \delta(q,\sigma)=q'
                    \end{equation*} \begin{itemize}
                        \item Significa che l'automa è nello stato $q$ e il prossimo simbolo da leggere è $\sigma$ (con $u$ come resto della stringa) e $\delta$ porta dallo stato $q$ allo stato $q'$ leggendo $\sigma$, allora l'automa si sposta nello stato $q'$ e il simbolo $\sigma$ viene "consumato" dall'input
                        \item Questa relazione di riduzione è \textbf{deterministica} (per ogni configurazione, c'è al più una transizione possibile) e \textbf{terminante} (ad ogni passo viene consumato un simbolo, quindi la computazione termina sempre)
                    \end{itemize}
                    \item \textbf{Configurazioni di Arresto (Halting Configurations)}: Le configurazioni di arresto sono quelle in cui non ci sono più simboli da leggere, quindi nella forma $\langle q,\varepsilon\rangle$. Un DFA non si blocca mai prima di aver letto tutto l'input, dato che la sua funzione di transizione $\delta$ è totale.
                    \item \textbf{Direttive di Input/Output}: Queste definiscono come l'input viene processato e come viene determinato il risultato finale: \begin{itemize}
                        \item \textbf{Input ($f_{IN}(u)$)}: data la stringa di input $u$, la configurazione iniziale è $f_{IN}(u)=\langle q_0, u\rangle$
                        \item \textbf{Output ($f_{OUT}(\langle q,u\rangle)$)}: il risultato di una computazione viene estratto dalla configurazione finale $\langle q,u\rangle$ nel modo seguente: \begin{equation*}
                            f_{OUT}(\langle q,u\rangle) = \begin{cases}
                                \text{True} & q\in F, u=\varepsilon\Rightarrow\text{ tutta la stringa è stata letta}\\
                                \text{False} & \text{altrimenti} 
                            \end{cases}
                        \end{equation*}
                    \end{itemize}
                    \item \textbf{Linguaggio accettato}: Il linguaggio $L(\mathcal{M})$ riconosciuto da un DFA $\mathcal{M}$ è l'insieme di tutte le stringhe $u$ tali per cui, partendo dalla configurazione iniziale $\langle q_0, u\rangle$, l'automa raggiunge una configurazione $\langle q,\varepsilon\rangle$. Formalmente: \begin{equation*}
                        L(\mathcal{M})=\left\{u\mid\langle q_0,u\rangle\to^*\langle q,\varepsilon\rangle, \text{ per qualche } q\in F\right\}
                    \end{equation*}
                    Esiste un modo equivalente per definire il linguaggio accettato, che utilizza una funzione di transizione estesa $\hat{\delta}:Q\times\Sigma^*\to Q$: \begin{itemize}
                        \item $\hat{\delta}(q, \varepsilon) = q$ (leggendo la stringa vuota, si rimane nello stato corrente)
                        \item $\hat{\delta}(q, u\sigma) = \delta(\hat{\delta}(q, u), \sigma)$ (per leggere una stringa $u$ seguita da un simbolo $\sigma$, si calcola prima lo stato raggiunto dopo aver letto $u$, e da quello stato si applica la funzione $\delta$ per leggere $\sigma$)
                    \end{itemize}
                    Una stringa $u$ è accettata se $\hat{\delta}(q_0, u) \in F$. Il linguaggio accettato (riconosciuto) da $\mathcal{M}$ è quindi: \begin{equation*}
                        L(\mathcal{M})=\left\{u\mid\hat{\delta}(q_0,u)\in F\right\}
                    \end{equation*}
                    I \textbf{linguaggi regolari} sono quelli accettati da qualche DFA.  
                \end{itemize}
                \begin{exercise}
                    \textit{Proviamo che $\emptyset,\{\varepsilon\}$ e $\Sigma^*$ sono insiemi regolari.}
                    \begin{itemize}
                        \item $\emptyset$: Per essere accettato abbiamo bisogno che $\mathcal{M}=\langle Q,\Sigma, \delta, q_0, F=\emptyset\rangle$ perchè $\emptyset\in F$ e perchè non viene accettato da quelle $\mathcal{M}\mid F\neq\emptyset$
                        \item $\{\varepsilon\}$: $F=\{q_0\}$ per definizione, quindi: \begin{itemize}
                            \item $Q=\{q_0,q_1\}$
                            \item $\Sigma$ qualunque ad esempio $\{a\}$
                            \item $\delta$ \begin{itemize}
                                \item $\delta(q_0,a)=q_1$
                                \item $\delta(q_1,a)=q_1$
                            \end{itemize} 
                        \end{itemize}
                        Quindi $\{\varepsilon\}$ è accettato perchè la DFA ha come solo stato finale $q_0$ e se dessimo in input la stringa "aa" porterebbe allo stato $q_1$ non finale e rimarrebbe bloccato lì ma $q_1\notin F$ quindi viene rifiutata.
                        \item $\Sigma^*$: Possiamo costruire una $\mathcal{M}$ molto semplice \begin{itemize}
                            \item $Q=\{q_0\}$
                            \item $F=\{q_0\}$
                            \item $\delta$\begin{itemize}
                                \item $\delta(q_0,\sigma)=q_0$
                            \end{itemize}
                        \end{itemize}
                        In questo modo qualsiasi sia l'alfabeto, l'automa consuma l'input e quando la stringa è vuota viene accettata.
                    \end{itemize}
                \end{exercise}
                \newpage
                Un DFA può essere rappresentato come un grafo orientato etichettato detto \textbf{grafo di transizione}
                \begin{center}
                    \includegraphics[width=0.3\textwidth]{Images/dfagraph.png}
                \end{center}
                Oppure dando una matrice di transizione
                \begin{center}
                    \begin{tabular}{|c|c|c|}
                        \hline
                         & 0 & 1 \\
                        \hline
                        $\displaystyle \to q_0$ & $q_1$ & $q_2$\\
                        \hline
                        $*q_1$& $q_1$ & $q_1$ \\
                        \hline
                        $q_2$ & $q_1$ & $q_0$ \\
                        \hline
                    \end{tabular}
                \end{center}
                Dove lo stato iniziale è indicato con $\to$ e lo stato finale con $*$.
                \begin{definitionbox}{Automa a stato finito non deterministico (NFA)}{}
                    E' una quintupla $\mathcal{M}=\langle Q,\Sigma, \delta, q_0, F\rangle$ dove $\delta:Q\times\Sigma\to\wp(Q)$.\\
                    $\wp(Q)$ mappa un \textbf{insieme di stati}, cioè l'insieme di tutti i sottoinsiemi possibili di $Q$. Ad esempio se abbiamo $Q=\{q_0,q_1,q_2\}$, $\wp(Q)=\left\{\{q_0\},\{q_1\},\{q_2\},\{q_0,q_1\},\ldots,\{q_0,q_1,q_2\}\right\}$
                \end{definitionbox}
                Analogamente ai DFA, un NFA può essere rappresentato in due modi principali:
                \begin{itemize}
                    \item \textbf{Grafo di transizione}: rimane concettualmente la stessa dei DFA
                    \item \textbf{Tabella di transizione}: ogni casella della tabella (corrispondente a una coppia stato/simbolo) può contenere un insieme di stati \begin{center}
                        \begin{tabular}{|c|c|c|}
                            \hline
                             & 0 & 1\\
                             \hline
                             $\to q_0$ & $\{q_0,q_1\}$ & $q_0$\\
                             \hline
                             $q_1$ & $\emptyset$ & $q_2$\\
                             \hline
                             $*q_2$ & $q_2$ & $q_2$\\
                            \hline
                        \end{tabular}
                    \end{center}
                \end{itemize}
                Il comportamento di un NFA è descritto da un sistema di transizione:
                \begin{itemize}
                    \item \textbf{Configurazioni}: Sono della forma $\langle q, u \rangle$, dove $q \in Q$ è lo stato corrente e $u \in \Sigma^*$ è la stringa ancora da leggere
                    \item \textbf{Relazione di riduzione}: È definita come: $\langle q, \sigma u \rangle \to \langle q', u \rangle$ se $q' \in \delta(q, \sigma)$. \textbf{Non è deterministica} ma comunque \textbf{terminante}, poichè a ogni passo viene consumato un simbolo di input (a meno che non si blocchi)
                    \item \textbf{Configurazioni di arresto}: Un NFA può bloccarsi in due modi: \begin{enumerate}
                        \item Quando ha letto tutta la stringa: $\langle q, \varepsilon \rangle$
                        \item Quando si trova in una configurazione $\langle q, \sigma u \rangle$ ma non esistono transizioni possibili per il simbolo $\sigma$ dallo stato $q$ (cioè $\delta(q, \sigma) = \emptyset$)
                    \end{enumerate}
                    \item \textbf{Direttive di Input/Output}: Le direttive di input/output sono simili a quelle dei DFA: \begin{itemize}
                        \item \textbf{Input}: $f_{IN}(u) = \langle q_0, u \rangle$
                        \item \textbf{Output}: $f_{OUT}=\begin{cases}
                            \langle q, u \rangle = \text{True} & \text{se }q \in F, u = \varepsilon\\
                            \text{False} & \text{altrimenti}
                        \end{cases}$
                    \end{itemize}
                    \item \textbf{Linguaggio Accettato}: Il linguaggio $L(\mathcal{M})$ accettato (o riconosciuto) da un NFA $\mathcal{M}$ è l'insieme delle stringhe $u$ per cui esiste almeno una computazione che, partendo dalla configurazione iniziale $\langle q_0, u \rangle$, raggiunge una configurazione $\langle q, \varepsilon \rangle$ dove $q$ è uno stato finale. Questo è un punto chiave del non determinismo: basta una computazione accettante tra tutte quelle possibili.\\
                    Un modo equivalente per definire il linguaggio accettato usa la funzione estesa $\hat{\delta} : Q \times \Sigma^* \to \wp(Q)$: \begin{itemize}
                        \item $\hat{\delta}(q, \varepsilon) = {q}$
                        \item $\hat{\delta}(q, u\sigma) = \bigcup_{q' \in \hat{\delta}(q, u)} \delta(q', \sigma)$
                    \end{itemize}
                    Con questa definizione, una stringa $u$ è accettata se e solo se esiste uno stato $q$ nell'insieme $\hat{\delta}(q_0, u)$ che sia uno stato finale ($q \in F$). In altre parole, $L(\mathcal{M}) = {u \mid \hat{\delta}(q_0, u) \cap F \neq \emptyset }$
                \end{itemize}
                \begin{theorembox}{Rabin-Scott}{}
                    Sia $\mathcal{M}=\langle Q,\Sigma,\delta_N,q_0,F_N\rangle$ un NFA. Allora esiste un DFA $\mathcal{M}_D$ tale che $L(\mathcal{M}_D)=L(\mathcal{M})$
                \end{theorembox}
                \textbf{Prova}: Costruiamo $\mathcal{M}_D$ come la quintupla $\langle\wp(Q),\Sigma,\delta_D,\{q_0\},F_D\rangle$. L'idea centrale della costruzione è che ogni stato del nuovo DFA $\mathcal{M}_D$ corrisponde a un insieme di stati dell'NFA originale.
                \begin{itemize}
                    \item $Q_D=\wp(Q_N)$: questo significa che ogni stato del DFA è un sottoinsieme degli stati dell'NFA. Se l'NFA ha $|Q_N|$ stati, il DFA risultante può avere fino a $2^{|Q_N|}$ stati, sebbene non tutti siano necessariamente raggiungibili.
                    \item $\delta_D$: per ogni stato $q_D\in\wp(Q_N)$ (che è un insieme di stati dell'NFA) e per ogni simbolo $\sigma \in \Sigma$, la transizione $\delta_D(q_D, \sigma)$ porta a un nuovo stato del DFA che è l'unione di tutti gli stati raggiungibili nell'NFA da qualsiasi stato in $q_D$ leggendo $\sigma$. Formalmente: \begin{equation*}
                        \delta_D(q_D, \sigma) = \bigcup_{q \in q_D} \delta_N(q, \sigma)
                    \end{equation*}
                    \item $F_D$: Uno stato $q_D \subseteq Q_N$ del DFA è uno stato finale se e solo se contiene almeno uno stato finale dell'NFA. Formalmente: \begin{equation*}
                        F_D = {q_D \subseteq Q_N \mid q_D \cap F_N \neq \emptyset}
                    \end{equation*}
                \end{itemize}
                \begin{example}{}
                    \begin{itemize}
                        \item \textbf{NFA Originale $\left(\mathcal{M}_N\right)$}: $\mathcal{M}=\left(\{q_0,q_1,q_2\},\{0,1\},\delta_N,q_0,q_2\right)$ con \begin{center}
                            $\delta_N=$ \begin{tabular}{|c|c|c|}
                                \hline
                                & 0 & 1 \\
                                \hline
                                $\to q_0$ & $q_0$ & $\{q_0,q_1\}$\\
                                \hline
                                $q_1$ & $\emptyset$ & $q_2$\\
                                \hline
                                $*q_2$ & $q_2$ & $q_2$\\
                                \hline
                            \end{tabular}
                        \end{center}
                        \item \textbf{DFA Derivante $(\mathcal{M}_D)$}: $\mathcal{M}_D=(Q_D,\{0,1\},\delta_D,q_0,F_D)$ \begin{itemize}
                            \item $Q_D=\{\emptyset,\{q_0\},\{q_1\},\{q_2\},\{q_0,q_1\},\{q_0,q_2\},\{q_1,q_2\},\{q_0,q_1,q_2\}\}$
                            \item $F_D=\{\{q_2\},\{q_0,q_2\},\{q_1,q_2\},\{q_0,q_1,q_2\}\}$ (tutti gli stati che contengono lo stato finale della NFA)
                            \item $\delta_D$: \begin{enumerate}
                                \item \textbf{Da $\{q_0\}$}: \begin{itemize}
                                    \item $\delta_D(q_0,0)=\delta_N(q_0,0)=q_0$
                                    \item $\delta_D(q_0,1)=\delta_N(q_0,1)=\{q_0,q_1\}$
                                \end{itemize}
                                \item \textbf{Da $\{q_0,q_1\}$}: \begin{itemize}
                                    \item $\delta_D(\{q_0,q_1\},0)=\delta_N(q_0,0)\cup \delta_N(q_1,0)=\{q_0\}\cup\emptyset=q_0$
                                    \item $\delta_D(\{q_0,q_1\},1)=\delta_N(q_0,1)\cup \delta_N(q_1,1)=\{q_0,q_1\}\cup\{q_2\}=\{q_0,q_1,q_2\}$ 
                                \end{itemize}
                                \item \textbf{Da $\{q_0,q_1,q_2\}$}: \begin{itemize}
                                    \item $\delta_D(\{q_0,q_1,q_2\},0)=\delta_N(q_0,0)\cup \delta_N(q_1,0)\cup\delta_N(q_2,0)=\{q_0\}\cup\emptyset\cup\{q_2\}=\{q_0,q_2\}$
                                    \item $\delta_D(\{q_0,q_1,q_2\},1)=\delta_N(q_0,1)\cup \delta_N(q_1,1)\cup\delta_N(q_2,1)=\{q_0,q_1\}\cup\{q_2\}\cup\{q_2\}=\{q_0,q_1,q_2\}$
                                \end{itemize}
                                \item \textbf{Da $\{q_0,q_2\}$}: \begin{itemize}
                                    \item $\delta_D(\{q_0,q_2\},0)=\delta_N(q_0,0)\cup \delta_N(q_2,0)=\{q_0\}\cup\{q_2\}=\{q_0,q_2\}$
                                    \item $\delta_D(\{q_0,q_2\},1)=\delta_N(q_0,1)\cup \delta_N(q_2,1)=\{q_0,q_1\}\cup\{q_2\}=\{q_0,q_1,q_2\}$
                                \end{itemize}
                            \end{enumerate}
                            Quindi \begin{center}
                                $\delta_D=$ \begin{tabular}{|c|c|c|}
                                \hline
                                & 0 & 1 \\
                                \hline
                                $\to q_0$ & $q_0$ & $\{q_0,q_1\}$\\
                                \hline
                                $\{q_0,q_1\}$ & $q_0$ & $\{q_0,q_1,q_2\}$\\
                                \hline
                                $*\{q_0,q_1,q_2\}$ & $\{q_0,q_2\}$ & $\{q_0,q_1,q_2\}$\\
                                \hline
                                $*\{q_0,q_2\}$ & $\{q_0,q_2\}$ & $\{q_0,q_1,q_2\}$\\
                                \hline
                            \end{tabular}
                            \end{center}
                        \end{itemize}
                    \end{itemize}
                    \textit{Abbiamo costruito la tabella includendo unicamente gli stati raggiungibili a partire da $\{q_0\}$. Secondo la definizione di $\delta_D$, non è necessario calcolare le transizioni per stati come $\{q_1\}$, $\{q_1,q_2\}$ e $\{q_2\}$, dato che non vengono mai raggiunti.}
                \end{example}
                \begin{demonstration}
                    \large\textbf{Dimostrazione per induzione}\normalsize\\
                    \textbf{Base}
                    \begin{itemize}
                        \item Per la definizione della funzione di transizione estesa in un DFA, $\hat{\delta}_D({q_0}, \varepsilon) = {q_0}$
                        \item Per la definizione della funzione di transizione estesa in un NFA, $\hat{\delta}_N(q_0, \varepsilon) = {q_0}$
                    \end{itemize}
                    Quindi, la condizione è soddisfatta per la stringa vuota: $\hat{\delta}_D({q_0}, \varepsilon) = \hat{\delta}_N(q_0, \varepsilon)$.\\
                    \textbf{Passo (Stringa $u\sigma$)}
                    \begin{itemize}
                        \item Assumiamo, per ipotesi induttiva, che per una generica stringa $u$, valga $\hat{\delta}_D({q_0}, u) = \hat{\delta}_N(q_0, u)$, vogliamo dimostrare che la stessa uguaglianza vale per la stringa $u\sigma$
                        \item Applichiamo la definizione di $\hat{\delta}_D$ a $u\sigma$: $\hat{\delta}_D({q_0}, u\sigma) = \delta_D(\hat{\delta}_D({q_0}, u), \sigma)$, possiamo sostituire $\hat{\delta}_D({q_0}, u)$ con $\hat{\delta}_N(q_0, u)$: $= \delta_D(\hat{\delta}_N(q_0, u), \sigma)$
                        \item Ora applichiamo la definizione di $\delta_D$: è l'unione delle transizioni $\delta_N(q', \sigma)$ per tutti gli stati $q'$ nell'insieme $\hat{\delta}_N(q_0, u)$:$= \bigcup_{q' \in \hat{\delta}_N(q_0, u)} \delta_N(q', \sigma)$. Questa è precisamente la definizione di $\hat{\delta}_N(q_0, u\sigma)$
                    \end{itemize}
                    Quindi, $\hat{\delta}_D({q_0}, u\sigma) = \hat{\delta}_N(q_0, u\sigma)$.\\
                    Avendo dimostrato per induzione che $\hat{\delta}_D({q_0}, u) = \hat{\delta}_N(q_0, u)$ per ogni stringa $u \in \Sigma^*$, possiamo concludere sull'accettazione del linguaggio:
                    \begin{itemize}
                        \item Una stringa $u$ è accettata dal DFA $\mathcal{M}_D$ se e solo se $\hat{\delta}_D({q_0}, u) \in F_D$
                        \item Per definizione di $F_D$, ciò significa che $\hat{\delta}_D({q_0}, u)$ deve contenere almeno uno stato finale di $\mathcal{M}_N$, ovvero $\hat{\delta}_D({q_0}, u) \cap F_N \neq \emptyset$
                        \item Poiché $\hat{\delta}_D({q_0}, u) = \hat{\delta}_N(q_0, u)$, questo è equivalente a $\hat{\delta}_N(q_0, u) \cap F_N \neq \emptyset$
                        \item E quest'ultima è la condizione di accettazione di una stringa per un NFA $\mathcal{M}_N$
                    \end{itemize}
                    Pertanto, $u$ è accettata da $\mathcal{M}_D$ se e solo se è accettata da $\mathcal{M}_N$, il che significa che $L(\mathcal{M}_D) = L(\mathcal{M}_N)$.
                \end{demonstration}
                \begin{definitionbox}{$\varepsilon$-NFA o NFA con transizioni silenti}{}
                    E' una quintupla $M = \langle Q, \Sigma, \delta, q_0, F \rangle$ dove la funzione di transizione, che ha la forma \begin{equation*}
                        \delta : Q \times (\Sigma \cup \{\varepsilon\}) \to \wp(Q)
                    \end{equation*}
                    La peculiarità di questa definizione è l'inclusione di $\varepsilon$ nell'alfabeto di input della funzione di transizione, il che consente transizioni tra stati senza consumare alcun simbolo di input (transizioni silenti). Questo permette, in molti casi, di costruire automi più semplici e leggibili
                \end{definitionbox}
                Il comportamento di un $\varepsilon$-NFA è descritto da un sistema di transizione con le seguenti caratteristiche:
                \begin{itemize}
                    \item \textbf{Configurazioni}: Sono della forma $\langle q, u \rangle$, dove $q \in Q$ è lo stato corrente e $u \in \Sigma^*$ è la stringa ancora da leggere
                    \item \textbf{Relazione di riduzione}: È definita in due modi: \begin{itemize}
                        \item $\langle q, \sigma u \rangle \to \langle q', u \rangle$ se $q' \in \delta(q, \sigma)$ (transizione standard, consumando un simbolo)
                        \item $\langle q, u \rangle \to \langle q', u \rangle$ se $q' \in \delta(q, \varepsilon)$ (transizione silente, senza consumare simboli)
                    \end{itemize}
                    La relazione di riduzione è non deterministica, anche per via della possibilità di scegliere tra leggere o non leggere un simbolo. È generalmente non terminante, ma le computazioni infinite sono dovute solo a cicli di transizioni $\varepsilon$ dallo stesso stato, che possono essere eliminati.
                    \item \textbf{Configurazione di arresto}: Oltre alle configurazioni della forma $\langle q, \varepsilon \rangle$, includono anche quelle in cui l'automa si blocca perché non ci sono transizioni possibili (né con simboli di input, né silenti) da un dato stato con il simbolo corrente
                    \item \textbf{Linguaggio accettato}: Le direttive di input/output sono le stesse degli NFA. Una stringa $u$ è accettata se esiste almeno una computazione che, partendo dalla configurazione iniziale $\langle q_0, u \rangle$, raggiunge una configurazione $\langle q, \varepsilon \rangle$ dove $q$ è uno stato finale. Un modo equivalente per definire il linguaggio accettato utilizza la funzione di transizione estesa $\hat{\delta} : Q \times \Sigma^* \to \wp(Q)$, che si basa sul concetto di $\varepsilon$-closure: \begin{itemize}
                        \item \textbf{$\varepsilon-closure(q)$}: È l'insieme di tutti gli stati raggiungibili da $q$ utilizzando zero o più transizioni $\varepsilon$. Formalmente, include $q$ stesso, tutti gli stati raggiungibili da $q$ tramite $\delta(q, \varepsilon)$, e ricorsivamente tutti gli stati raggiungibili da questi ultimi tramite ulteriori transizioni $\varepsilon$
                        \item \textbf{Funzione di transizione estesa $\hat{\delta}$}: \begin{itemize}
                            \item $\hat{\delta}(q, \varepsilon) = \varepsilon\text{-closure}(q)$
                            \item $\hat{\delta}(q, u\sigma) = \bigcup_{q' \in \hat{\delta}(q, u)} \varepsilon\text{-closure}(\delta(q', \sigma))$
                        \end{itemize}
                        Una stringa $u$ è accettata se e solo se l'insieme di stati raggiungibili dopo aver letto $u$ (cioè $\hat{\delta}(q_0, u)$) contiene almeno uno stato finale ($\hat{\delta}(q_0, u) \cap F \neq \emptyset$)
                    \end{itemize}
                \end{itemize}
                \begin{example}
                    $\mathcal{M}_N=(\{q_0,q_1,q_2\},\{a,b\},\delta_N,q_0,F_N)$
                    \begin{center}
                        $\delta_N=$ \begin{tabular}{|c|c|c|c|}
                            \hline
                             & a & b & $\varepsilon$\\
                            \hline
                            $\to q_0$ & \ldots & \ldots & $q_1$\\
                            \hline
                            $q_1$ & \ldots & \ldots & $q_2$\\
                            \hline
                            $*q_2$ & \ldots & \ldots & $q_1$\\
                            \hline
                        \end{tabular}
                    \end{center}
                    \textbf{Calcolo le $\varepsilon-closure$}: \begin{itemize}
                        \item $\varepsilon-closure(q_0)=\{q_0,q_1,q_2\}$
                        \item $\varepsilon-closure(q_1)=\{q_1,q_2\}$
                        \item $\varepsilon-closure(q_2)=\{q_2,q_1\}$
                    \end{itemize}
                \end{example}
        \section{Minimizzazione di DFA}
            La minimizzazione di un DFA mira a trovare un automa equivalente, che accetti lo stesso linguaggio, ma con il numero minimo di stati.
            \begin{itemize}
                \item \textbf{Stati indistinguibili ($q\sim q'$)}: sono considerati indistinguibili (o equivalenti) se il linguaggio accettato a partire da $q$ è identico al linguaggio accettato a partire da $q'$. Ciò significa che per qualsiasi stringa $u\in\Sigma^*$, se $\hat{\delta}(q,u)\in F$ allora anche $\hat{\delta}(q',u)\text{ (deve) }\in F$ e viceversa. Questa relazione di indistinguibilità è una relazione di equivalenza.
                \item \textbf{Classe di equivalenza ($\equivalenceclass{q}$)}: è l'insieme di tutti gli elementi di $Q$ che sono in relazione con $q$ ($\forall x\in Q, x\sim q$)
                \item \textbf{Quoziente di $Q$ ($\quotientof{Q}$)}: è l'insieme i cui elementi sono le classi di equivalenza stesse,\\
                $\quotientof{Q}=\{\equivalenceclass{q}\mid q\in Q\}$
            \end{itemize}
            \underline{Due stati indistinguibili possono intuitivamente essere trasformati in un unico stato}.\\
            Quindi:
            \begin{equation*}
                \mathcal{M'}=\langle\quotientof{Q},\Sigma,\delta',\equivalenceclass{q_0},F'\rangle
            \end{equation*}
            \subsection{Algoritmo}
                \begin{enumerate}
                    \item Suddividiamo gli stati in due classi di equivalenza: quelli finali e quelli non finali
                    \item A ogni passo consideriamo le classi di equivalenza ottenute al passo precedente \begin{enumerate}
                        \item  Per ognuna di esse immaginiamo che tutti gli stati all'interno leggano un $\sigma$
                        \item Se tutti gli stati finiscono in altri stati della stessa classe di equivalenza, allora questi stati sono ancora considerati simili per quel $\sigma$
                        \item Altrimenti quei due stati non sono più indistinguibili. A questo punto la classe di equivalenza viene suddivisa in sottogruppi più piccoli, separando gli stati che si comportano in modo diverso
                    \end{enumerate}
                    \item Torniamo al punto (2.) e ripetiamo il processo, l'algoritmo si ferma solo quando, dopo aver controllato tutti i grupi con tutti i simboli, non c'è più nulla da dividere 
                \end{enumerate}
                \begin{lstlisting}
                ind = {insieme di (q,q') indistinguibili};
                old_ind = null;
                while(ind != old_ind) {
                    old_ind = ind;
                    ind = null;
                    for each (q,q') in old_ind {
                        ok = true;
                        for simb in alfabeto {
                            if(!indistinguibili(delta(q,simb),delta(q',simb))){
                                ok = false;
                                break;
                            }
                        }
                        if (ok) {
                            ind = ind + (q,q');
                        }
                    }
                }
                \end{lstlisting}
                \begin{example}
                    Consideriamo il seguente DFA:
                    \begin{center}
                        \begin{tabular}{|c|c|c|}
                            \hline
                            & \textbf{a} & \textbf{b}\\
                            \hline
                            $\to q_0$ & $q_0$ & $q_1$ \\
                            \hline
                            $q_1$ & $q_1$ & $q_2$ \\
                            \hline
                            $q_2$ & $q_2$ & $q_3$ \\
                            \hline
                            $*q_3$ & $q_3$ & $q_3$ \\
                            \hline
                        \end{tabular}
                    \end{center}
                    \begin{enumerate}
                        \item $\sim\,=\{\{q_3\},\{q_0,q_1,q_2\}\}$
                        \item \textbf{Prima iterazione}: \begin{enumerate}
                            \item Consideriamo $\{q_0,q_1,q_2\}$
                            \item Leggiamo 'a': \begin{enumerate}
                                \item $\delta(q_0,a)=q_0 \in \{q_0,q_1,q_2\}$
                                \item $\delta(q_1,a)=q_1 \in \{q_0,q_1,q_2\}$
                                \item $\delta(q_2,a)=q_2 \in \{q_0,q_1,q_2\}$
                            \end{enumerate}
                            \item Leggiamo 'b': \begin{enumerate}
                                \item $\delta(q_0,b)=q_1 \in \{q_0,q_1,q_2\}$
                                \item $\delta(q_1,b)=q_2 \in \{q_0,q_1,q_2\}$
                                \item $\delta(q_2,b)=q_3 \notin \{q_0,q_1,q_2\}$
                            \end{enumerate}
                            \item Quindi $\sim\,=\{\{q_3\},\{q_0,q_1\},\{q_2\}\}$
                        \end{enumerate}
                        \item \textbf{Seconda iterazione}: \begin{enumerate}
                            \item Consideriamo $\{q_0,q_1\}$
                            \item Leggiamo 'a': \begin{enumerate}
                                \item $\delta(q_0,a)=q_0 \in \{q_0,q_1\}$
                                \item $\delta(q_1,a)=q_1 \in \{q_0,q_1\}$
                            \end{enumerate}
                            \item Leggiamo 'b': \begin{enumerate}
                                \item $\delta(q_0,b)=q_1 \in \{q_0,q_1\}$
                                \item $\delta(q_1,b)=q_2 \notin \{q_0,q_1\}$
                            \end{enumerate}
                            \item Quindi $\sim\,=\{\{q_3\},\{q_0\},\{q_1\},\{q_2\}\}$
                        \end{enumerate}
                    \end{enumerate}
                    Quindi il DFA era già minimo.
                \end{example}
                \begin{example}
                    \begin{center}
                        \includegraphics[width=0.8\textwidth]{Images/minimizzazionefebbraio2024.png}
                    \end{center}
                    \footnotesize
                    \begin{enumerate}
                        \item Costruiamo la tabella di transizione (non necessaria ma aiuta): \begin{center}
                            \begin{tabular}{|c|c|c|}
                                \hline
                                & \textbf{a} & \textbf{b}\\
                                \hline
                                $\to$1 & 2 & 7\\
                                \hline
                                2 & 6 & 3 \\
                                \hline
                                7 & 2 & 9\\
                                \hline
                                6 & 10 & 3\\
                                \hline
                                3 & 8 & 9\\
                                \hline
                                9 & 4 & 10\\
                                \hline
                                $*$10 & 10 & 10\\
                                \hline
                                8 & 5 & 7\\
                                \hline
                                4 & 5 & 3\\
                                \hline
                                5 & 10 & 7\\
                                \hline
                            \end{tabular}
                        \end{center}
                        \item $\sim\,=\{\{10\},\{1,2,3,4,5,6,7,8,9\}\}$
                        \item \textbf{Prima iterazione}: \begin{enumerate}
                            \item Consideriamo $\{1,2,3,4,5,6,7,8,9\}$
                            \item Leggiamo 'a': \begin{enumerate}
                                \item $\delta(1,a)=2$
                                \item $\delta(2,a)=6$
                                \item $\delta(3,a)=8$
                                \item $\delta(4,a)=5$
                                \item $\delta(5,a)=10\notin\{1,2,3,4,5,6,7,8,9\}$
                                \item $\delta(6,a)=10\notin\{1,2,3,4,5,6,7,8,9\}$
                                \item $\delta(7,a)=2$
                                \item $\delta(8,a)=5$
                                \item $\delta(9,a)=4$
                            \end{enumerate}
                            \item Leggiamo 'b': \begin{enumerate}
                                \item $\delta(1,b)=7$
                                \item $\delta(2,b)=3$
                                \item $\delta(3,b)=9$
                                \item $\delta(4,b)=3$
                                \item $\delta(7,b)=9$
                                \item $\delta(8,b)=7$
                                \item $\delta(9,b)=10\notin\{1,2,3,4,5,6,7,8,9\}$
                            \end{enumerate}
                            \item Quindi $\sim\,=\{\{10\},\{5,6\},\{9\},\{1,2,3,4,7,8\}\}$
                        \end{enumerate}
                        \item Nella seconda (e ultima in questo caso) iterazione avremo che $\sim\,=\{\{10\},\{5,6\},\{9\},\{1\},\{2,4,8\},\{3,7\}\}$
                    \end{enumerate}
                \end{example}
            \subsection{Espressioni regolari}
                \begin{definitionbox}{}{}
                    Un'espressione regolare è una stringa che descrive schematicamente un insieme di stringhe. I linguaggi denotati dalle RE sono definiti induttivamente: 
                    \begin{itemize}
                        \item $\emptyset$ è una RE che denota il linguaggio vuoto
                        \item $\varepsilon$ è una RE che denota il linguaggio contenente solo la stringa vuota $\{\varepsilon\}$
                        \item Per ogni simbolo $\sigma\in\Sigma$, $\sigma$ è una RE che denota il linguaggio $\{\sigma\}$
                        \item Se $r_1$ è un'espressione regolare che denota il linguaggio $L_1$ e $r_2$ denota $L_2$, allora: \begin{itemize}
                            \item $r_1+r_2$ (o $r_1\mid r_2$) denota l'unione dei linguaggi $L_1\cup L_2$
                            \item $r_1r_2$ denota la concatenazione dei linguaggi $L_1\cdot L_2$
                        \end{itemize}
                        \item Se $r$ è un'espressione regolare che denota $L$, $r^*$ denota la chiusura di Kleene $L^*$
                    \end{itemize}
                \end{definitionbox}
        \section{Proprietà dei linguaggi regolari}
            \begin{itemize}
                \item \textbf{Unione}: Se $L$ e $L'$ sono linguaggi regolari, anche la loro unione ($L \cup L'$) è un linguaggio regolare. Questa proprietà è "ovvia per definizione" in relazione alle espressioni regolari.
                \item \textbf{Concatenazione}: Se $L$ e $L'$ sono linguaggi regolari, anche la loro concatenazione ($L \cdot L'$) è un linguaggio regolare. Anche questa è "ovvia per definizione".
                \item \textbf{Chiusura di Kleene}: Se $L$ è un linguaggio regolare, anche la sua chiusura di Kleene ($L^*$) è un linguaggio regolare. Questa proprietà è anch'essa "ovvia per definizione".
                \item \textbf{Complementazione}: Se $L$ è un linguaggio regolare su un alfabeto $\Sigma$, allora anche il suo complementare ($\overline{L} = \Sigma^* \setminus L$) è regolare. Questo si dimostra prendendo un DFA che riconosce $L$ e scambiando gli stati finali con quelli non finali.
                \item \textbf{Intersezione}: Se $L$ e $L'$ sono linguaggi regolari, allora anche la loro intersezione ($L \cap L'$) è un linguaggio regolare. La chiusura rispetto all'intersezione si deduce facilmente dalla chiusura per complementazione, dato che $L \cap L' = \overline{\overline{L} \cup \overline{L'}}$.
            \end{itemize}
            \subsection{Pumping Lemma}
                \begin{theorembox}{Pumping Lemma}{}
                    Sia $L$ un linguaggio regolare. Allora esiste una costante $n\in\mathbb{N}$ (detta "lunghezza di pompaggio" o "numero di stati del DFA") tale che, per ogni $z\in L$ con $|z|\geq n$, possiamo decomporre $z$ come $uvw$ in modo che: \begin{itemize}
                        \item $|uv|\geq n$ (la porzione "pompabile" $v$ deve trovarsi entro i primi $n$ simboli della stringa)
                        \item $|v|>0$ (la porzione "pompabile" non deve essere vuota)
                        \item per ogni $i\geq 0$ si ha che $uv^iw\in L$ ($v$ può essere ripetuta $i$ volte, inclusa l'eliminazione $i=0$, e la stringa rimarrà nel linguaggio)
                    \end{itemize}
                \end{theorembox}
                \begin{demonstration}
                    \begin{itemize}
                        \item Assumiamo $L$ regolare $\Rightarrow$ per il Pumping Lemma, esiste una costante $n$.
                        \item Si sceglie una stringa $z=\sigma_1\sigma_2\ldots\sigma_{|z|}\in L$ la cui lunghezza $|z|\geq n$.
                        \item Dato che la stringa è accettata dall'automaa, abbiamo $q_0\xrightarrow{\sigma_1}q_1\xrightarrow{\sigma_2}\ldots\xrightarrow{\sigma_{|z|}}q_{|z|}=q_F\in F$
                        \item Dato che il DFA ha solo $n$ stati in totale, necessariamente si ha che almeno uno stato $\bar{q}$ viene attraversato due volte nei primi $n$ passi, ossia $\bar{q}=q_i=q_j$ per qualche $0\leq i<j\leq n$
                        \item \textbf{Decomposizione di z}: \begin{itemize}
                            \item $u=\sigma_1\ldots\sigma_i$
                            \item $v=\sigma_{i+1}\ldots\sigma_j$
                            \item $w=\sigma_{j+1}\ldots\sigma_{|z|}$
                        \end{itemize}
                        si ha $q_0\xrightarrow{u}\bar{q}\xrightarrow{v}\bar{q}\xrightarrow{w}q_F$, quindi $q_0\xrightarrow{u}\bar{q}\xrightarrow{v^i}\bar{q}\xrightarrow{w}q_F$ perchè $\bar{q}\xrightarrow{v}\bar{q}$
                    \end{itemize}
                \end{demonstration}

                Il pumping lemma viene tipicamente utilizzato per provare che un linguaggio $L$ \textbf{non} è regolare.\\
                A tale scopo: \begin{itemize}
                    \item Si sceglie un numero arbitrario $n$
                    \item Si trova una stringa $z\in L$, con lunghezza $|z|\geq n$
                    \item Si dimostra che, per ogni modo in cui si può dividere $z$ in tre parti $uvw$ (dove $|uv|\leq n$ e $|v|>0$), se si ripete la parte $v$ (o la si elimina), la stringa che si ottiene \textbf{non} appartiene più al linguaggio
                \end{itemize}
                Questo contraddice la definizione di linguaggio regolare, provando così che il linguaggio non lo è.
                \begin{example}
                    Possiamo dimostrare, utilizzando il pumping lemma, che il linguaggio $\{0^n1^n\}$ non è regolare. Infatti, preso $n$ arbitrario, consideriamo la stringa $0^n1^n$. Decomponendo tale stringa in tre parti $u, v, w$ tali che la lunghezza delle prime due sia $\leq n$ e la seconda sia non vuota, si ha chiaramente $u = 0^a$, $v = 0^b$ e $w = 0^c1^n$ con $a+b+c = n$, $b > 0$. Allora, per esempio per $i = 0$, si ha che $uv^0w = 0^a0^c1^n$ non appartiene al linguaggio in quanto $a+c < n$.
                \end{example}
        \section{Automi a pila}
            \begin{definitionbox}{Automa a pila non deterministico (PDA)}{}
                E' una tupla \begin{equation*}
                    \mathcal{M}=\langle Q,\Sigma,\Gamma,\delta,q_0,Z,F\rangle
                \end{equation*}
                \begin{itemize}
                    \item $Q,\Sigma,q_0,F$ come per gli automi a stati finiti
                    \item $\Gamma$: alfabeto della pila
                    \item $Z$: simbolo inziale della pila
                    \item $\delta:Q\times(\Sigma\cup\{\varepsilon\})\times\Gamma\to\wp_F(Q\times\Gamma^*)$, dove $\wp_F(X)$ denota l'insieme dei sottoinsiemi \textit{finiti} di $X$
                \end{itemize}
            \end{definitionbox}
            In termini informali, quando un automa a pila si trova nello stato $q$, legge un simbolo $\sigma$ (o esegue una transizione silente) e rimuove il simbolo in cima $Z$ dalla pila, può passare a un nuovo stato $q'$ e inserire una sequenza $\alpha$ (anche vuota) di nuovi simboli in cima alla pila.\\
            L'automa è \textbf{non deterministico}, il che significa che per la stessa combinazione di stato, simbolo di input corrente e simbolo in cima alla pila, possono esserci diverse transizioni possibili.
            Il comportamento di un PDA è descritto da un sistema di transizione con le seguenti caratteristiche:
            \begin{itemize}
                \item \textbf{Configurazioni}: sono nella forma $\langle q,u,\alpha\rangle$ dove $q\in Q$ è lo stato corrente, $u\in\Sigma^*$ è la stringa ancora da leggere e $\alpha\in\Gamma^*$ è il contenuto corrente della pila
                \item \textbf{Relazione di riduzione}: Descrive come la macchina si muove da una configurazione all'altra: \begin{itemize}
                    \item $\langle q, \sigma u, X \alpha \rangle \rightarrow \langle q', u, \gamma \alpha \rangle$ se $\langle q', \gamma \rangle \in \delta \langle q, \sigma, X \rangle$ (lettura di un simbolo di input $\sigma$)
                    \item $\langle q, u, X \alpha \rangle \rightarrow \langle q', u, \gamma \alpha \rangle$ se $\langle q', \gamma \rangle \in \delta \langle q, \varepsilon, X \rangle$ (transizione silente $\varepsilon$)
                \end{itemize}
                La relazione di riduzione è non deterministica. Ciò significa che per una data configurazione, potrebbero esserci più transizioni possibili, incluse le transizioni silenti. Le computazioni possono essere non terminanti se ci sono cicli di transizioni $\varepsilon$ che non modificano l'input o la pila in modo significativo per il consumo della stringa
                \item \textbf{Configurazioni di arresto}: Si verificano quando non ci sono ulteriori mosse possibili
                \item \textbf{Direttive di Input/Output}: \begin{itemize}
                    \item \textbf{Input}: $f_{IN}(u)=\langle q_0, u, Z \rangle$
                    \item \textbf{Output}: \begin{itemize}
                        \item Riconoscimento per pila vuota (Empty Stack Acceptance): \begin{equation*}
                            f_{OUT}(\langle q, u, \alpha \rangle)= \begin{cases} \text{True} & \text{se } u = \varepsilon \text{ e } \alpha = \varepsilon \\ \text{False} & \text{altrimenti} \end{cases}
                        \end{equation*}
                        \item Riconoscimento per stati finali (Final State Acceptance): \begin{equation*}
                            f_{OUT}(\langle q, u, \alpha \rangle) = \begin{cases} \text{True} & \text{se } u = \varepsilon \text{ e } q \in F \\ \text{False} & \text{altrimenti} \end{cases}
                        \end{equation*}
                    \end{itemize}
                \end{itemize}
                \item \textbf{Linguaggio accettato}: \begin{itemize}
                    \item Per pila vuota: $L(\mathcal{M})=\{u\in\Sigma^*\mid\langle q_0,u,Z\rangle\to^*\langle\_,\varepsilon,\varepsilon\rangle\}$
                    \item Per stati finali: $L(\mathcal{M})=\{u\in\Sigma^*\mid\langle q_0,u,Z\rangle\to^*\langle q,\varepsilon,\_\rangle,q\in F\}$
                \end{itemize}
                Usiamo la wildcar \_ per sottolineare il fatto che lo stato non è rilevante.\\
                \textit{Le due definizioni sono equivalenti: se il linguaggio $L$ è riconosciuto da un qualche PDA secondo la prima definizione, allora esiste anche un PDA che lo riconosce secondo l'altra e viceversa}.
            \end{itemize}
            \begin{definitionbox}{Automa a pila deterministico (DPDA)}{}
                 E' una tupla $\mathcal{M} = \langle Q, \Sigma, \Gamma, \delta, q_0, Z, F \rangle$ dove: \begin{itemize}
                    \item $Q$, $\Sigma$, $q_0$ e $F$ sono come per gli automi a stati finiti
                    \item $\Gamma$ è l'alfabeto della pila
                    \item $Z$ è il simbolo iniziale nella pila
                    \item $\delta : Q \times (\Sigma \cup {\varepsilon}) \times \Gamma \to \mathcal{P}_F(Q \times \Gamma^*)$ soddisfa la seguente condizione di determinismo:
                    \\Per ogni $\langle q, \sigma, X \rangle \in Q \times \Sigma \times \Gamma$: $$|\delta\langle q, \sigma, X \rangle| + |\delta\langle q, \varepsilon, X \rangle| \le 1$$
                 \end{itemize}
                 Questa condizione garantisce che per ogni stato corrente $q$, simbolo di input corrente $\sigma$ (o transizione silente $\varepsilon$), e simbolo in cima alla pila $X$, esista al più una transizione possibile. Non è possibile, ad esempio, leggere un simbolo di input e contemporaneamente avere una transizione silente dallo stesso stato con lo stesso simbolo in cima alla pila.
            \end{definitionbox}
        \section{Linguaggi Context-Free}
        \subsection{Grammatiche Context-Free}
            \begin{definitionbox}{Grammatica CF}{}
                Una CFG è definita da una quadrupla $\langle T, N, P, S \rangle$:
                \begin{itemize}
                    \item $T$ è l'alfabeto dei terminali (i simboli che compongono le stringhe del linguaggio)
                    \item $N$ è l'alfabeto dei non terminali (simboli intermedi usati nelle derivazioni), con $T \cap N = \emptyset$
                    \item $P$ è un insieme finito di produzioni (o regole), della forma $A ::= \alpha$, dove $A \in N$ e $\alpha \in (T \cup N)^*$
                    \item $S \in N$ è il simbolo iniziale (o assioma), da cui partono le derivazioni
                \end{itemize}
            \end{definitionbox}
            \begin{example}
                \begin{itemize}
                    \item $T=\{0,1,\ldots,9\}$
                    \item $N=\{Exp,Num\}$
                    \item $P=\{Exp:=Num, Exp:=(Exp+Exp), Num:=T\}$
                    \item $S=Exp$
                \end{itemize}
            \end{example}
            \begin{definitionbox}{Derivazione in un passo}{}
                Questa nozione è fondamentale per comprendere come una grammatica context-free (CFG) genera le stringhe di un linguaggio.\\
                Si considerano una grammatica $G = \langle T, N, P, S \rangle$. Si prendono due stringhe, $\alpha$ e $\beta$, che possono contenere sia simboli terminali che non terminali (ovvero $\alpha, \beta \in (T \cup N)^*$).\\
                Si dice che $\beta$ è derivabile da $\alpha$ in un passo se valgono le seguenti condizioni: \begin{itemize}
                    \item La stringa $\alpha$ ha la forma $\alpha_1 A \alpha_2$. Questo significa che $\alpha$ contiene un non terminale $A$, circondato da due (eventualmente vuote) sottostringhe $\alpha_1$ e $\alpha_2$, che possono essere composte da terminali e non terminali ($\alpha_1, \alpha_2 \in (T \cup N)^*$)
                    \item La stringa $\beta$ ha la forma $\alpha_1 \gamma \alpha_2$
                    \item Esiste una produzione (regola) $A ::= \gamma$ nell'insieme $P$ delle produzioni della grammatica. Qui $A$ è il non terminale che viene espanso e $\gamma$ è la stringa (di terminali e/o non terminali) con cui $A$ viene sostituito
                \end{itemize}
                 La derivazione in un passo è indicata con $\alpha \to \beta$. Questa relazione è una relazione su $(T \cup N)^*$.
            \end{definitionbox}
            \textbf{Chiusura Riflessiva e transitiva ($\rightarrow^*$)}: \begin{itemize}
                \item La chiusura riflessiva e transitiva di $\rightarrow$ è indicata con $\rightarrow^*$
                \item Si dice che $\beta$ è derivabile da $\alpha$ (in uno o più passi, o anche zero passi se $\alpha = \beta$) se $\alpha \rightarrow^* \beta$
                \item Questa significa che si può ottenere $\beta$ partendo da $\alpha$ attraverso una sequenza di zero o più applicazioni delle regole di derivazione in un passo
            \end{itemize}
            \begin{definitionbox}{Linguaggio generato da una grammatica}{}
                Data una grammatica Context-Free (CF) $G = \langle T, N, P, S \rangle$, il linguaggio generato da $G$, denotato $L(G)$, è definito come l'insieme di tutte le stringhe $u$ che appartengono all'alfabeto dei terminali $T^*$ e che possono essere derivate dal simbolo iniziale $S$: \begin{equation*}
                    L(G)=\{u\in T^*\mid S\to^* u\}
                \end{equation*}
            \end{definitionbox}
            Un linguaggio $L$ è definito Context-Free (CF) se esiste una grammatica CF $G$ che lo genera, ovvero tale che $L(G) = L$.\\
            Talvolta, l'interesse può estendersi non solo al linguaggio generato dall'assioma ($S$), ma a una famiglia di linguaggi generati a partire da ciascun non terminale della grammatica (ad esempio, $L_A(G) = {u \in T^* \mid A \rightarrow^* u}$). In tal caso, la scelta di un assioma specifico non è l'unico aspetto significativo.
        \subsection{Proprietà}
            \begin{definitionbox}{Pumping Lemma}{}
                Se $L$ è un linguaggio CF, esiste una costante $n\in\mathbb{N}$ (lunghezza di pompaggio) tale che, per ogni $z\in L$ con $|z|\geq n$ può essere decomposta in $uvwxy$ in modo che:
                \begin{itemize}
                    \item $|vwx|\geq n$
                    \item $|vx|>0$
                    \item $\forall i\geq 0$ si ha che la stringa $uv^iwx^iy\in L$
                \end{itemize} 
            \end{definitionbox}
            L'idea fondamentale di questo lemma è che, se un linguaggio è CF, allora ogni sua stringa che sia "sufficientemente lunga" può essere divisa in cinque parti. Due di queste parti possono essere ripetute (o eliminate) un numero qualsiasi di volte, e la stringa risultante apparterrà ancora al linguaggio.
            \begin{demonstration}
                \textbf{Prova}: Qualsiasi linguaggio CF (che non includa la stringa vuota $\varepsilon$, per semplicità) può essere generato da una grammatica CF che sia in Forma Normale di Chomsky (CNF). Una grammatica in CNF ha solo due tipi di produzioni (regole di riscrittura): \begin{itemize}
                    \item Un non-terminale che produce due altri non-terminali (es. $A ::= BC$)
                    \item Un non-terminale che produce un singolo simbolo terminale (es. $A ::= \sigma$)
                \end{itemize}
                Proviamo che, per una grammatica in CNF, se un albero di derivazione ha altezza m, allora la stringa finale che genera (la "frontiera" dell'albero) ha una lunghezza massima di $2^{(m-1)}$.\\
                \textbf{Base}: Un albero di altezza 1 significa che il simbolo di partenza ha prodotto direttamente un terminale (es. $S ::= \sigma$). La stringa ha lunghezza 1. E $2^{(1-1)} = 2^0 = 1$. Quindi, il caso base funziona.\\
                \textbf{Passo}: Un albero di altezza $m+1$ significa che il simbolo di partenza ha prodotto due altri non-terminali di altezza $m$ (es. $A::=BC$) le cui stringhe saranno di lunghezza al più $2^{(m-1)}$. Quindi: 
                $$|A|=2^{(m-1)} + 2^{(m-1)}=2^m$$
                Prendiamo $m$ come il numero di non-terminali della grammatica CNF che genera il linguaggio $L$ e stabiliamo $n=2^m$. Data una stringa $z\in L\mid|z|\geq n$, l'altezza del suo albero di derivazione deve essere \textbf{almeno} $m+1$. Visto che l'altezza dell'albero è maggiore del numero di non-terminali, sappiamo sicuramente che un non-terminale compaia due volte in un cammino dalla radice alle foglie (\textbf{Principio dei Cassetti}).
                \begin{itemize}
                    \item Indichiamo con $A^{(1)}$ e $A^{(2)}$ la prima e seconda occorrenza del non-terminale ripetuto
                    \item Supponiamo di avere $z=uvwxy$ dove: \begin{itemize}
                        \item $A^{(1)}$ genera la sottostringa $vwx$
                        \item $A^{(2)}$, contenuta in $A^{(1)}$, genera solo $w$
                        \item Le condizioni del lemma specificano: \begin{itemize}
                            \item $|vwx| \leq n$ perché abbiamo scelto la ripetizione più vicina alle foglie (cioè quella con altezza minore).
                            \item $|vx| > 0$ perché in una grammatica CNF non è possibile che entrambi $v$ e $x$ siano vuoti.
                        \end{itemize}
                    \end{itemize}
                \end{itemize}
                  Poiché $A$ può generare sia $vwx$ che $w$, è possibile ripetere o eliminare $v$ e $x$. Questo significa che le stringhe $uv^iwx^iy$ (per $i \geq 0$) apparterranno tutte al linguaggio.
            \end{demonstration}
            Come nel caso dei regolari, il pumping lemma viene utilizzato per provare che un linguaggio $L$ non è CF.\\
            Per farlo, bisogna scegliere un numero $n$ qualunque, e poi trovare una stringa $z$ che: \begin{itemize}
                \item Appartiene al linguaggio $L$
                \item Ha lunghezza almeno $n$, cioè $|z|\geq n$
            \end{itemize}
            A questo punto, mostriamo che qualunque modo si scelga di dividere $z$ nella forma $$z=uvwxy$$
            rispettando le due condizioni: 
            \begin{itemize}
                \item $|vwx|\leq n$
                \item $|vx|>0$
            \end{itemize}
            allora esiste almeno un valore di $i$ per cui la stringa "pompata"
            $$uv^iwx^iy$$
            non appartiene al linguaggio $L$.
            \begin{example}
                \textit{Provare che $L=\{a^nb^nc^n\}$ non è CF.}
                \begin{enumerate}
                    \item Per assurdo consideriamo $L$ CF
                    \item Scegliamo la stringa "più lunga": $z=a^nb^nc^n$, la lunghezza sarà $|z|=3n\geq n$
                    \item Sappiamo che $z$ può essere decomposta come $uvwxy$
                    \item Applichiamo il lemma: \begin{enumerate}
                        \item $|vwx|\leq n$
                        \item $|vx|>0$
                        \item $\forall i\geq 0, uv^iwx^iy$
                        \item Per certo possiamo dire che $vwx$ non può includere $a$ e $c$ perchè dovrebbe includere tutto $b^n$ e quindi la lunghezza sarebbe in ogni caso $> n$
                        \item Impostiamo $i=0$ (solitamente si usa $i=0$ o $i=2$): $uv^0wx^0y=uwy$ con $|uwy|=|u|+|w|+|y|$
                        \item $|z|=|u|+|v|+|w|+|x|+|y|\Rightarrow |uwy|=|z|-(|v|+|x|)$
                        \item Poichè $|vx|>0$, ne consegue che $|uwy| < |z|$
                    \end{enumerate}
                    \item $L$ non è CF
                \end{enumerate}
            \end{example}
            \subsubsection{Proprietà di Chiusura}
                I linguaggi CF risultano chiusi rispetto a:
                \begin{itemize}
                    \item \textbf{Unione}
                    \item \textbf{Concatenazione}
                    \item \textbf{Chiusura di Kleene}
                \end{itemize}
                I linguaggi CF non risultano chiusi rispetto a:
                \begin{itemize}
                    \item \textbf{Intersezione}
                    \item \textbf{Complementazione}
                \end{itemize}
\end{document}